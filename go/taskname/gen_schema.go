//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"runtime"
	"sort"
	"strings"

	"go.skia.org/infra/go/exec"
	"go.skia.org/infra/go/git"
	"go.skia.org/infra/go/gitiles"
	"go.skia.org/infra/go/sklog"
	"go.skia.org/infra/go/taskname"
)

const (
	TARGET_FILE = "task_name_schema_gen.go"
	TMPL        = `// Code generated by "go run gen_schema.go"; DO NOT EDIT

package taskname

var SCHEMA_FROM_GIT = map[string]*Schema{
%s}

var SEPARATOR_FROM_GIT = "%s"
`
)

type taskNameSchema struct {
	// Schema maps a role (e.g. Build) to a taskname.Schema instance.
	// Note, the json names are a carryover from Buildbot days, where builder == task
	Schema map[string]*taskname.Schema `json:"builder_name_schema"`
	// TaskNameSep specifies how the various keys will be seperated, e.g. "-"
	TaskNameSep string `json:"builder_name_sep"`
}

func main() {
	_, filename, _, _ := runtime.Caller(0)
	pkgDir := path.Dir(filename)

	// Load the schema from JSON
	r := gitiles.NewRepo("https://skia.googlesource.com/skia", nil)
	b, err := r.ReadFileAtRef(context.Background(), "infra/bots/recipe_modules/builder_name_schema/builder_name_schema.json", git.MainBranch)
	if err != nil {
		sklog.Fatalf("Could not read schema file: %s\n", err)
	}
	schema := new(taskNameSchema)
	if err := json.NewDecoder(bytes.NewReader(b)).Decode(schema); err != nil {
		sklog.Fatalf("Could not decode schema file: %s\n", err)
	}

	schemaLines := []string{}
	for key, value := range schema.Schema {
		line := fmt.Sprintf("\t\"%s\": %#v,\n", key, value)
		// "%#v" includes the package name, ie "taskname.Schema",
		// but since the generated file is part of the taskname
		// package, that results in a circular import. So we remove it
		// here.
		line = strings.Replace(line, "taskname.", "", -1)
		schemaLines = append(schemaLines, line)
	}
	sort.Strings(schemaLines)
	assetsStr := strings.Join(schemaLines, "")
	fileContents := []byte(fmt.Sprintf(TMPL, assetsStr, schema.TaskNameSep))
	targetFile := path.Join(pkgDir, TARGET_FILE)
	if err := ioutil.WriteFile(targetFile, fileContents, os.ModePerm); err != nil {
		sklog.Fatal(err)
	}
	if _, err := exec.RunCwd(context.Background(), ".", "gofmt", "-s", "-w", targetFile); err != nil {
		sklog.Fatal(err)
	}
}
