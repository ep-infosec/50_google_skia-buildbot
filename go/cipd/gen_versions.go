//go:build ignore
// +build ignore

package main

/*
	Generate asset_versions_gen.go.
*/

import (
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"sort"
	"strings"

	"go.skia.org/infra/go/cipd"
	"go.skia.org/infra/go/exec"
	"go.skia.org/infra/go/sklog"
	"go.skia.org/infra/go/util"
)

const (
	TARGET_FILE = "asset_versions_gen.go"
	HEADER      = `// Code generated by "go run gen_versions.go"; DO NOT EDIT

package cipd

var PACKAGES = map[string]*Package{
`
	FOOTER = `}`
)

func main() {
	_, filename, _, _ := runtime.Caller(0)
	pkgDir := path.Dir(filename)
	rootDir := path.Join(pkgDir, "..", "..")

	// Read packages from cipd.ensure.
	pkgs, err := cipd.ParseEnsureFile(filepath.Join(rootDir, "cipd.ensure"))
	if err != nil {
		sklog.Fatal(err)
	}

	// List the assets.
	assetsDir := path.Join(rootDir, "infra", "bots", "assets")
	entries, err := ioutil.ReadDir(assetsDir)
	if err != nil {
		sklog.Fatal(err)
	}
	for _, e := range entries {
		if e.IsDir() {
			contents, err := ioutil.ReadFile(path.Join(assetsDir, e.Name(), "VERSION"))
			if err == nil {
				name := e.Name()
				fullName := fmt.Sprintf("skia/bots/%s", name)
				pkgs = append(pkgs, &cipd.Package{
					Path:    name,
					Name:    fullName,
					Version: cipd.VersionTag(strings.TrimSpace(string(contents))),
				})
			} else if !os.IsNotExist(err) {
				sklog.Fatal(err)
			}
		}
	}

	// Write the file.
	sort.Sort(cipd.PackageSlice(pkgs))
	targetFile := path.Join(pkgDir, TARGET_FILE)
	if err := util.WithWriteFile(targetFile, func(w io.Writer) error {
		_, err := w.Write([]byte(HEADER))
		if err != nil {
			return err
		}
		for _, pkg := range pkgs {
			_, err := fmt.Fprintf(w, fmt.Sprintf(`	"%s": &Package{
		Path: "%s",
		Name: "%s",
		Version: "%s",
	},
`, pkg.Name, pkg.Path, pkg.Name, pkg.Version))
			if err != nil {
				return err
			}
		}
		_, err = w.Write([]byte(FOOTER))
		return err
	}); err != nil {
		sklog.Fatal(err)
	}
	if _, err := exec.RunCwd(context.Background(), ".", "gofmt", "-s", "-w", targetFile); err != nil {
		sklog.Fatal(err)
	}
}
